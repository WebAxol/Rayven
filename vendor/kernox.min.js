/******/ // The require scope
/******/ var __webpack_require__ = {};
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  mx: () => (/* reexport */ ArrayList),
  wE: () => (/* binding */ Kernox),
  iQ: () => (/* reexport */ System)
});

;// ./lib/addon/AddonLoader.js
class AddonLoader {
    constructor(__kernox) {
        this.__kernox = __kernox;
        this.__namespaces = new Set();
    }
    /**
     * Integrates an 'addon' to the application instance, registering and setting up resources.
     * @param addon Object that packages resources belonging to a context: it can contain a list of systems, collections, event listeners
     * and entity prototypes, which will be registered.
     * @example
     * import { Kernox, KernoAddon } from "../../dist/kernox.js";
     
     const app = new Kernox();

     // Recommended setup structure:
     
     import { prototypes  }   from "./setup/prototypes.js";
     import { listeners   }   from "./setup/listeners.js";
     import { systems     }   from "./setup/systems.js";
     import { collections }   from "./setup/collections.js";
     
     // Resource bundler (Addon)
     
     const demoApp : KernoAddon = {
         name : "demoApp",
         prototypes,
         systems,
         collections,
         listeners
     };
          
    app.use(demoApp); // << Integrating addon to application
     */
    use(addon) {
        const { name } = addon;
        if (this.namespaces.has(name)) {
            throw new Error(`Conflict with already existing namespace '${name}', please consider renaming one of them.`);
        }
        if (addon.collections)
            this.registerCollections(addon.collections, name);
        if (addon.prototypes)
            this.registerPrototypes(addon.prototypes, name);
        if (addon.systems)
            this.registerSystems(addon.systems, name);
        this.namespaces.add(name);
    }
    /**
     * Retrieves all namespaces registered. A namespace indicates the context a resource belongs to: every addon has its own namespace,
     * which isolates their resources, preventing name collisions.
     * @returns A string set containing all namespaces
     * @example
     * import { Kernox, KernoAddon } from "../../dist/kernox.js";
     * const app = new Kernox();
     *
     * app.use({
     *     name : "physics"
     *     // ...
     * });
     *
     * app.use({
     *     name : "graphics"
     *     // ...
     * });
     *
     * app.addonLoader.namespaces(); // Set(2) { "physics", "graphics" }
     
     */
    get namespaces() {
        return this.__namespaces;
    }
    registerPrototypes(prototypes, namespace) {
        prototypes.forEach(proto => {
            this.__kernox.entityFactory.prototype(proto, namespace);
        });
    }
    registerCollections(collections, namespace) {
        collections.forEach(collection => {
            this.__kernox.collectionManager.use(collection, namespace);
        });
    }
    registerSystems(systems, namespace) {
        systems.forEach(system => {
            this.__kernox.systemManager.use(system, namespace);
        });
    }
}
//# sourceMappingURL=AddonLoader.js.map
;// ./lib/collection/AbstractCollection.js
class AbstractCollection {
}
//# sourceMappingURL=AbstractCollection.js.map
;// ./lib/utils/isSubclassOf.js
function isSubclassOf(child, parent) {
    let proto = child.prototype;
    while (proto) {
        proto = Object.getPrototypeOf(proto);
        if (proto === parent.prototype) {
            return true;
        }
    }
    return false;
}
//# sourceMappingURL=isSubclassOf.js.map
;// ./lib/collection/CollectionManager.js


class CollectionManager {
    constructor(__kernox) {
        this.__kernox = __kernox;
        this.collections = new Map();
        this.toRemove = new Set();
    }
    /**
     * Searches for a collection by name and retrieves it if found.
     * @param collectionName Name of collection
     * @returns
     */
    get(collectionName) {
        const collection = this.collections.get(collectionName) || this.resolveImplicitNamespace(collectionName);
        if (!collection) {
            throw new Error(`Collection '${collectionName}' is not registered.`);
        }
        return collection;
    }
    /**
     * Registers new collection based on a constructor; the collection is identified by the name of its parent class.
     * @param Ctr sub-class of AbstractCollection.
     * @param namespace Optional parameter used by AddonLoader to specify a context when loading collections from an addon.
     */
    use(Ctr, namespace = '') {
        if (!(isSubclassOf(Ctr, AbstractCollection))) {
            throw new Error("Invalid collection: it must be a sub-class of AbstractCollection");
        }
        const name = namespace ? `${namespace}.${Ctr.name}` : Ctr.name;
        if (this.collections.has(name)) {
            throw new Error(`Cannot register collection '${name}' because it already exists`);
        }
        const collection = new Ctr();
        this.collections.set(name, collection);
    }
    addEntityTo(entity, collectionName) {
        const collection = this.get(collectionName);
        collection.insert(entity);
        entity.linkTo(collectionName);
    }
    removeEntityFrom(entity, collectionName) {
        const collection = this.get(collectionName);
        collection.remove(entity);
        entity.unlinkFrom(collectionName);
    }
    remindToForget(entity) {
        this.toRemove.add(entity);
    }
    flushRemoved() {
        for (const entity of this.toRemove) {
            for (const collectionName of entity.collections()) {
                this.removeEntityFrom(entity, collectionName);
            }
        }
        this.toRemove.clear();
    }
    resolveImplicitNamespace(collectionName) {
        const namespaces = this.__kernox.addonLoader.namespaces;
        var resolved, resource;
        for (const namespace of namespaces) {
            resource = this.collections.get(`${namespace}.${collectionName}`);
            if (resource && !resolved)
                resolved = resource;
            else if (resource) {
                throw new Error(`Ambiguous collection '${collectionName}' was requested: a namespace must be specified before it ( Ex. namespace.collectionName ).`);
            }
        }
        return resolved;
    }
}
//# sourceMappingURL=CollectionManager.js.map
;// ./lib/entity/Entity.js
/**
 * First class citizen object whose attributes can be inherited from n other entity types, can be
 * subscribed to entity collections and processed by other functions or class methods. It does not contain behaviour appart from getters and state validators.
 */
class Entity {
    constructor(__ID, __TYPE) {
        this.__ID = __ID;
        this.__TYPE = __TYPE;
        this.__children = {};
        this.__collections = new Set();
        this.__modified = false;
    }
    get id() {
        return this.__ID;
    }
    get type() {
        return this.__TYPE;
    }
    belongsTo(collectionName) {
        return this.__collections.has(collectionName);
    }
    collections() {
        return this.__collections;
    }
    linkTo(collectionName) {
        this.__collections.add(collectionName);
    }
    unlinkFrom(collectionName) {
        this.__collections.delete(collectionName);
    }
    appendChild(name, child) {
        if (this.__children[name])
            throw Error(`Child already exists with name '${name}' at entity '${this.__ID}'`);
        this.__children[name] = child;
    }
    getChild(name) {
        return this.__children[name];
    }
    deleteChild(name) {
        delete this.__children[name];
    }
}
//# sourceMappingURL=Entity.js.map
;// ./lib/entity/EntityFactory.js

class EntityFactory {
    constructor(__kernox) {
        this.__kernox = __kernox;
        this.types = new Map();
        this.pools = new Map();
        this.nextID = 0;
    }
    /**
     * Registers an entity prototype, based on which entities from a type will be created. The prototype can
     * extend one or more existing prototypes, resulting on a base object having all attributes of its parents.
     * @param prototype Schema that defines the prototype attributes, and other details
     * @param namespace Specifies the addon-related context of the given prototype
     * @example
     *
     * import { Kernox } from "kernox";
     * import type { Entity, PrototypeSchema } from "kernox";

        // Application instance

        const app = new Kernox();
        
        // Interface of entity type (optional but recommended)

        export interface Circle extends Entity {
            position   : Vector2D;
            radius     : number;
            color      : string;
        };
        
        // Define prototype of type 'Circle'

        export const circlePrototype : PrototypeSchema<Circle> = {
            name : "Circle",
            attributes : {
                position   : new Vector2D(0,0),
                radius : 1,
                color : "rgb(255,0,0)"
            } as Circle,
            collections : new Set([ "Renderables" ])
        };
     
        // Register prototype

        app.entityFactory.prototype(circlePrototype);
     */
    prototype(prototype, namespace = '') {
        const name = namespace ? `${namespace}.${prototype.name}` : prototype.name;
        if (this.types.has(name))
            throw Error(`The type named '${name}' has already been registered`);
        // Inherit attributes and collections from parent types
        const { inherits } = prototype;
        if (inherits) {
            const parents = inherits;
            const stack = [];
            for (const parent of parents) {
                stack.push(parent);
            }
            let current = stack.pop();
            while (current) {
                // Copy each property from parent type to the new type
                const temp = {};
                this.deepAssign(temp, current.attributes);
                this.deepAssign(temp, prototype.attributes);
                prototype.attributes = temp;
                // Join type collections with collections belonging to parent type
                prototype.collections = new Set([
                    ...(prototype.collections || []),
                    ...(current.collections || [])
                ]);
                for (const parent of (current.inherits || [])) {
                    stack.push(parent);
                }
                current = stack.pop();
            }
        }
        this.types.set(name, prototype);
    }
    /**
     * Instantiates an entity: an object populated with the attributes defined by its prototype, which by default
     * contains the same values as it. Specific values can be assigned by adding them to the 'params' dictionary.
     * @param type Entity type, related to an existing prototype
     * @param params Dictionary of custom parameters, with which an entity's matching attributes will be defined
     * @returns An entity of the given type built based on its prototype (and parameters if any)
     */
    create(type, params = {}) {
        const prototype = this.types.get(type) || this.resolveImplicitNamespace(type);
        if (!prototype) {
            throw Error(`Cannot create entity of null type '${type}'`);
        }
        const entity = new Entity('' + this.nextID++, type);
        this.deepAssign(entity, prototype.attributes);
        for (const param of Object.keys(params)) {
            if (param in entity && !param.includes("_"))
                entity[param] = params[param];
        }
        // Extract context (namespace) for automatic inference whenever collection context isn't explicit.
        const splitted = type.split(".");
        const context = splitted.length == 2 ? splitted[0] : undefined;
        // Assign entity to collections
        for (let collection of (prototype.collections || [])) {
            if (context)
                collection = `${context}.${collection}`;
            this.__kernox.collectionManager.addEntityTo(entity, collection);
            entity.linkTo(collection);
        }
        return entity;
    }
    copyFromPrototype(recipient, prototype) {
        this.deepAssign(recipient, prototype.attributes);
    }
    sendToRest(entity) {
    }
    resolveImplicitNamespace(type) {
        const namespaces = this.__kernox.addonLoader.namespaces;
        var resolved, resource;
        for (const namespace of namespaces) {
            resource = this.types.get(`${namespace}.${type}`);
            if (resource && !resolved)
                resolved = resource;
            else if (resource)
                throw new Error(`Ambiguous entity type '${type}' was requested: a namespace must be specified before it ( Ex. namespace.type ).`);
        }
        return resolved;
    }
    /**
     * Copies all attributes of a prototype into a recipient; if the prototype contains
     * objects or instances, original references are untouched, and deep copies are created instead.
     * @param recipient Destiny object, which will carry the properties
     * @param prototype Base object, from which properties are copied
     * @param seen (internal) Stores already assigned objects to avoid reasigning them on recursive calls
     * @returns Nothing, it mutates the recipient object
     */
    deepAssign(recipient, prototype, seen = new WeakMap()) {
        if (seen.has(prototype))
            return;
        seen.set(prototype, recipient);
        for (const key of Object.keys(prototype)) {
            const value = prototype[key];
            // Primitives
            if (value === null || typeof value !== 'object') {
                recipient[key] = value;
            }
            // Arrays
            else if (Array.isArray(value)) {
                recipient[key] = [];
                this.deepAssign(recipient[key], value, seen);
            }
            // Class instance
            else if (value.constructor !== Object) {
                recipient[key] = new value.constructor();
                this.deepAssign(recipient[key], value, seen);
            }
            // Plane object
            else {
                recipient[key] = {};
                this.deepAssign(recipient[key], value, seen);
            }
        }
    }
}
//# sourceMappingURL=EntityFactory.js.map
;// ./lib/event/EventBroker.js
class EventBroker {
    constructor(__kernox) {
        this.__kernox = __kernox;
        this.listeners = new Map();
    }
    /**
     * Dispatches an event to all listeners.
     * @param eventName The name of the event to dispatch.
     * @param detail Optional payload.
     * @example

     * import { app } from "./main"; // << Your application instance
     *
     * // Fire event...
     * app.eventBroker.dispatch("test", {
     *     message : "A test event was fired"
     * });
     *
     * // Note: you may call this method whenever something special happens at your systems
     */
    dispatch(eventName, detail) {
        const listeners = this.listeners[eventName] || this.resolveImplicitNamespace(eventName);
        if (!listeners)
            return false;
        for (const handler of listeners)
            handler(detail);
        return true;
    }
    /**
     * Subscribes function to a given event.
     * @param eventName The event to listen to.
     * @param handler Handler function which will be called when the event is fired
     * @example
     *
     * import { Kernox, System } from "kernox";
     *
     * const app = new Kernox(); // << Your application instance
     *
     * const onPlayerMove = (details) => {
     *     console.log("Event was fired", details);
     * };
     *
     * app.eventBroker.attachToEvent("playerMove", onPlayerMove);
     */
    attachToEvent(eventName, handler) {
        if (!eventName || typeof eventName != "string") {
            throw new Error(`[EventManager] invalid event name provided: it must be a non-empty string`);
        }
        if (typeof handler !== "function") {
            throw new Error(`Expected function as 'handler'`);
        }
        if (!this.listeners[eventName])
            this.listeners[eventName] = new Set();
        return this.listeners[eventName].add(handler);
    }
    resolveImplicitNamespace(eventName) {
        const namespaces = this.__kernox.addonLoader.namespaces;
        var resolved, resource;
        for (const namespace of namespaces) {
            resource = this.listeners[`${namespace}.${eventName}`];
            if (resource && !resolved)
                resolved = resource;
            else if (resource) {
                throw new Error(`Ambiguous event '${eventName}' was requested: a namespace must be specified before it ( Ex. namespace.eventName ).`);
            }
        }
        return resolved;
    }
}
//# sourceMappingURL=EventBroker.js.map
;// ./lib/system/System.js
/**
 * Encapsulates application logic which is part of kernox's execution loop.
 *
 * Systems are firt-class-citizens: they can emit and listen to events, request and update collections,
 * and process entities.
 */
class System {
    constructor(__kernox, __context) {
        this.__kernox = __kernox;
        this.__context = __context;
        this.__paused = false;
    }
    /**
     * Called once during addon setup.
     */
    init() { }
    /**
     * Method called by kernox on every frame, when paused is false.
     */
    execute() { }
    /**
     * Name of the addon the system is related to.
     */
    get context() {
        return this.__context;
    }
    /**
     * Prevents the execution of the system when true.
     */
    get paused() {
        return this.__paused;
    }
    set paused(state) {
        this.__paused = state;
    }
    /**
     * Attaches callback to an event, so it is called whenever the event is emitted.
     *
     * Note: By default, the system's context is assumed, unless a namespace is defined (ex. eventName = 'physics.collision').
     * @param eventName Name of the event (it is registered if not yet).
     * @param callback Handler function that receives one parameter.
     * @returns True if attachment was successfull, false otherwise.
     * @example
     *
     * import { System } from "kernox";
     *
     * class MovementSystem extends System {
     *
     *    public init(){
     *       this.attachToEvent("playerInput", this.onPlayerInput)
     *    };
     *
     *    public execute(){
     *      // Etc...
     *    }
     *
     *    public onPlayerInput(details){
     *       console.log("The player interacted", details);
     *    }
     * };
     */
    attachToEvent(eventName, handler) {
        const resourceName = this.resolveResourceName(eventName);
        return this.__kernox.eventBroker.attachToEvent(resourceName, handler);
    }
    /**
     * Notifies an event to the EventBroker.
     *
     * Note: By default, the system's context is assumed, unless a namespace is defined (ex. eventName = 'physics.collision').
     * @param eventName Name of the event.
     * @param details Additional information related to the event.
     * @example
     * import { System } from "kernox";
     * import { player } from "./player";
     *
     * class MovementSystem extends System {
     *
     *    public init(){
     *       this.attachToEvent("playerInput", this.onPlayerInput)
     *    };
     *
     *    public execute(){
     *      if(player.jumped) this.dispatchEvent("playerJump", { player });
     *      // Event triggered when player jumps ^^^
     *    }
     * };
     */
    dispatchEvent(eventName, details) {
        this.__kernox.eventBroker.dispatch(eventName, details);
    }
    /**
     * Retrieves a collection to CollectionManager if found.
     * @param collectionName Name of collection
     * @returns an entitity collection or undefined
     */
    getCollection(collectionName) {
        const resourceName = this.resolveResourceName(collectionName);
        const collection = this.__kernox.collectionManager.get(resourceName);
        if (!collection)
            throw Error(`Collection '${resourceName}' was not found`);
        return collection;
    }
    /**
     * @param resourceName Name of whatever it is being requested
     * @returns
     */
    resolveResourceName(resourceName) {
        const splittedName = resourceName.split(".");
        var context = this.context;
        var baseName = resourceName;
        if (splittedName.length == 2)
            [context, baseName] = splittedName;
        const fullName = context ? `${context}.${baseName}` : resourceName;
        return fullName;
    }
}
//# sourceMappingURL=System.js.map
;// ./lib/system/SystemManager.js


class SystemManager {
    constructor(__kernox) {
        this.__kernox = __kernox;
        this.systems = new Map();
        this.executionList = [];
    }
    /**
     * @description Executes all systems sequentially.
     * Systems are executed in the order they were registered.
     */
    execute() {
        this.executionList.forEach((system) => { if (!system.paused)
            system.execute(); });
    }
    /**
     * @description Vinculates a system, so that it's execution method is called on every frame.
     * @param system An instance of 'System'.
     * @returns True if new system is registered, false otherwise.
     */
    use(Ctor, namespace = '') {
        const systemName = namespace ? `${namespace}.${Ctor.name}` : Ctor.name;
        if (!isSubclassOf(Ctor, System)) {
            throw new Error("Expected instance of 'System'");
        }
        if (this.systems.has(systemName)) {
            console.warn(`System '${systemName}' is already registered`);
            return false;
        }
        const system = new Ctor(this.__kernox, namespace);
        system.init();
        this.systems.set(systemName, system);
        this.executionList.push(system);
        return true;
    }
    /**
     * Removes system from the execution list and registry.
     * @param systemName A string corresponding to the class of the system to remove.
     */
    unuse(systemName) {
        const system = this.systems.get(systemName);
        if (!system)
            return;
        this.systems.delete(systemName);
        this.executionList = this.executionList.filter(s => s !== system);
    }
    get(systemName) {
        return this.systems.get(systemName);
    }
}
//# sourceMappingURL=SystemManager.js.map
;// ./lib/collection/ArrayList.js

class ArrayList extends AbstractCollection {
    constructor() {
        super(...arguments);
        this.entities = new Set();
        this.__changed = false;
    }
    /**
     * Appends an entity at the end of the current collection.
     * @returns True if a new entity was added, and false otherwise.
     */
    insert(entity) {
        if (this.has(entity))
            return false;
        this.entities.add(entity);
        entity.linkTo(this.constructor.name);
        this.__changed = true;
        return true;
    }
    /**
     * Removes an entity from the current collection, if exists.
     * @returns True if the entity was removed, and false otherwise.
     */
    remove(entity) {
        if (!this.entities.delete(entity))
            return false;
        entity.unlinkFrom(this.constructor.name);
        this.__changed = true;
        return true;
    }
    /**
     * Evaluates if a given entity belongs to the collection.
     */
    has(entity) {
        return this.entities.has(entity);
    }
    *[Symbol.iterator]() {
        const arr = this.toArray();
        for (let i = 0; i < this.size(); i++) {
            yield arr[i];
        }
    }
    /**
     * @param start Initial index: by default equals zero.
     * @param end   Final index; if negative, it points from right to left (ej. -1 points to last element).
     * @param step  Index increment: can be positive or negative, but not be zero. Equals one by default.
     * @returns An iterator for a given index range and step constant.
     * @example
     *
     * for(const entity of collection.iterator(0,10,2)){
     *     // Iterates from index zero to ten incrementing by two each time
     *     console.log(entity);
     * }
     *
     * for(const entity of collection.iterator(0,-1,1)){
     *     // Iterates from index zero to last
     *     console.log(entity);
     * }
     *
     */
    iterator(start = 0, end = -1, step = 1) {
        if (step == 0) {
            throw Error("Attempted to create non-changing iterator: 'step' parameter cannot be zero");
        }
        const size = this.size();
        if (end < 0)
            end = size - end;
        // Limit iteration ranges to avoid indices out of range
        start = Math.max(0, start) - 1;
        end = Math.min(end, size - 1);
        var index = start;
        const entities = this.toArray();
        return {
            [Symbol.iterator]() {
                return this;
            },
            next() {
                if (index < size && index <= end)
                    return { value: entities[index += step], done: false };
                else
                    return { value: undefined, done: true };
            }
        };
    }
    /**
     * @returns An array populated with all entities within the collection.
     */
    toArray() {
        return Array.from(this.entities);
    }
    /**
     * @param criteria Boolean callback used to filter entities.
     * @returns Similar to 'toArray', but returns a filtered array of entities from the collection.
     */
    filter(criteria) {
        return this.toArray().filter(criteria);
    }
    /**
     * @returns The number of entities within the collection.
     */
    size() {
        return this.entities.size;
    }
    get changed() {
        return this.__changed;
    }
}
//# sourceMappingURL=ArrayList.js.map
;// ./lib/Kernox.js







/**
 * Top-level application component: central integration point that handles all resources, including entities,
 * collections, systems, and events.
 */
class Kernox {
    constructor() {
        this.__entityFactory = new EntityFactory(this);
        this.__collectionManager = new CollectionManager(this);
        this.__systemManager = new SystemManager(this);
        this.__eventBroker = new EventBroker(this);
        this.__addonLoader = new AddonLoader(this);
        this.__frame = 0;
        this.__paused = false;
        this.__lastTime = 0;
        this.__dt = 1;
        this.__fps = 0;
    }
    /**
     * Kernox's top-level method, it starts the execution loop triggering subordinate systems.
     */
    execute(timeSpan = 30) {
        try {
            if (this.paused)
                return;
            this.__dt = timeSpan - this.__lastTime;
            this.__fps = 1000 / this.dt;
            this.__lastTime = timeSpan;
            requestAnimationFrame((timeSpan) => this.execute(timeSpan));
            this.__systemManager.execute();
            this.__frame++;
        }
        catch (err) {
            console.error(err);
            console.warn("A run-time error has occurred, execution was paused");
            this.__paused = true;
        }
    }
    /**
       * Integrates an 'addon' to the application instance, registering and setting up resources.
       * @param addon Object that packages resources belonging to a context: it can contain a list of systems, collections, event listeners
       * and entity prototypes, which will be registered.
       * @example
       * import { Kernox, KernoAddon } from "../../dist/kernox.js";
       
       const app = new Kernox();
  
       // Recommended setup structure:
       
       import { prototypes  }   from "./setup/prototypes.js";
       import { listeners   }   from "./setup/listeners.js";
       import { systems     }   from "./setup/systems.js";
       import { collections }   from "./setup/collections.js";
       
       // Resource bundler (Addon)
       
       const demoApp : KernoAddon = {
           name : "demoApp",
           prototypes,
           systems,
           collections,
           listeners
       };
            
      app.addonLoader.use(demoApp); // << Integrating addon to application
       */
    use(addon) {
        this.__addonLoader.use(addon);
    }
    /**
     * Manages the construction and recycling of entities, and can assamble prototypes to define archetypes;
     * it creates an object pools for each archetype to allocate unused entities for posterior reusal.
     */
    get entityFactory() {
        return this.__entityFactory;
    }
    /**
     * Creates, retrieves and updates collections. A collection is a data structure containing entities; there are
     * several types of collections: linear (array), sorted (array), etc...
     */
    get collectionManager() {
        return this.__collectionManager;
    }
    /**
     * Vinculates and runs System instances sequentially.
     */
    get systemManager() {
        return this.__systemManager;
    }
    /**
     * Dispatches emitted events to subscribed systems, by calling their handler method.
     */
    get eventBroker() {
        return this.__eventBroker;
    }
    get addonLoader() {
        return this.__addonLoader;
    }
    get frame() {
        return this.__frame;
    }
    get paused() {
        return this.__paused;
    }
    get dt() {
        return this.__dt;
    }
    get fps() {
        return this.__fps;
    }
}

//# sourceMappingURL=Kernox.js.map
var __webpack_exports__ArrayList = __webpack_exports__.mx;
var __webpack_exports__Kernox = __webpack_exports__.wE;
var __webpack_exports__System = __webpack_exports__.iQ;
export { __webpack_exports__ArrayList as ArrayList, __webpack_exports__Kernox as Kernox, __webpack_exports__System as System };
